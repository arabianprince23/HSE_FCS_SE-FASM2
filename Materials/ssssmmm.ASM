format PE console
entry start

include 'win32a.inc'

;--------------------------------------------------------------------------
section '.data' data readable writable

strVecSize db 'size of vector? ', 0
strVecx db 'x? ', 0
strArrWithout db 'Array without x', 10, 0
strIncorSize db 'Incorrect size of vector = %d', 10, 0
strVecElemI db '[%d]? ', 0
strScanInt db '%d', 0
strSumValue db '', 10, 0
strVecElemOut db '[%d] = %d', 10, 0
strCurrArray db 'Input array:', 10, 0
strNewStr db '', 10, 0

vec_size dd 0
x dd 0
sum dd 0
i dd ?
tmp dd ?
tmpStack dd ?
vec rd 100

;--------------------------------------------------------------------------
section '.code' code readable executable
start:
; 1) vector input
call GetX
call VectorInput
; 2) get vector sum
call VectorSum
; 3) out of sum
push [sum]
push strSumValue
call [printf]
; 4) test vector out
push strCurrArray
call [printf]
call VectorOut
push strNewStr
call [printf]

push strArrWithout
call [printf]
add esp, 4

call VectorOutX
finish:
call [getch]

push 0
call [ExitProcess]

;--------------------------------------------------------------------------
VectorInput:
push strVecSize
call [printf]
add esp, 4

push vec_size
push strScanInt
call [scanf]
add esp, 8

mov eax, [vec_size]
cmp eax, 0
jg getVector
; fail size
push vec_size
push strIncorSize
call [printf]
push 0
call [ExitProcess]
; else continue...

GetX:
push strVecx
call [printf]
add esp, 4

push x
push strScanInt
call [scanf]
add esp, 8

ret

getVector:
xor ecx, ecx ; ecx = 0
mov ebx, vec ; ebx = &vec
getVecLoop:
mov [tmp], ebx
cmp ecx, [vec_size]
jge endInputVector ; to end of loop

; input element
mov [i], ecx
push ecx
push strVecElemI
call [printf]
add esp, 8

push ebx
push strScanInt
call [scanf]
add esp, 8

mov ecx, [i]
inc ecx
mov ebx, [tmp]
add ebx, 4
jmp getVecLoop
endInputVector:
ret
;--------------------------------------------------------------------------
VectorSum:
xor ecx, ecx ; ecx = 0
mov ebx, vec ; ebx = &vec
sumVecLoop:
;mov [tmp], ebx
cmp ecx, [vec_size]
je endSumVector ; to end of loop
mov eax, [sum]
add eax, [ebx]
mov [sum], eax
;mov [i], ecx

;mov ecx, [i]
inc ecx
;mov ebx, [tmp]
add ebx, 4
jmp sumVecLoop
endSumVector:
ret
;--------------------------------------------------------------------------
VectorOut:
mov [tmpStack], esp
xor ecx, ecx ; ecx = 0
mov ebx, vec ; ebx = &vec
putVecLoop:
mov [tmp], ebx
cmp ecx, [vec_size]
je endOutputVector ; to end of loop

mov edi, [x]
cmp [tmp], edi
je endOutputVector
mov [i], ecx

; output element
push dword [ebx] ; [ebx] array elem
push ecx
push strVecElemOut
call [printf]

mov ecx, [i]
inc ecx
mov ebx, [tmp]
add ebx, 4
jmp putVecLoop
endOutputVector:
mov esp, [tmpStack]
ret

;--------------------------------------------------------------------------
VectorOutX:
mov [tmpStack], esp
xor ecx, ecx ; ecx = 0
mov ebx, vec ; ebx = &vec
putVecXLoop:
mov [tmp], ebx
cmp ecx, [vec_size]
je endOutputVectorX ; to end of loop
mov [i], ecx

; output element
push edi [x]
cmp [ebx] ,edi
jne PrintIfNotEqual

mov ecx, [i]
inc ecx
mov ebx, [tmp]
add ebx, 4
jmp putVecXLoop

PrintIfNotEqual:

push dword [ebx]
push ecx
push strVecElemOut
call [printf]
mov ecx, [i]
inc ecx
mov ebx, [tmp]
add ebx, 4
jmp putVecXLoop

endOutputVectorX:
mov esp, [tmpStack]
ret
;-------------------------------third act - including HeapApi--------------------------

section '.idata' import data readable
library kernel, 'kernel32.dll',\
msvcrt, 'msvcrt.dll',\
user32,'USER32.DLL'

include 'api\user32.inc'
include 'api\kernel32.inc'
import kernel,\
ExitProcess, 'ExitProcess',\
HeapCreate,'HeapCreate',\
HeapAlloc,'HeapAlloc'
include 'api\kernel32.inc'
import msvcrt,\
printf, 'printf',\
scanf, 'scanf',\
getch, '_getch'